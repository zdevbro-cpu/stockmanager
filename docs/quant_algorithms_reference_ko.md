# 퀀트(Quant) 알고리즘 참고 문서 (주식 종목추천/시스템 구축용)

> 목적: “주식 종목추천” 시스템에서 흔히 쓰는 **퀀트 알고리즘을 설계·구현·검증·운영**까지 한 번에 참고할 수 있도록, 핵심 개념과 실무 체크리스트를 문서 형태로 정리했습니다.  
> 범위: 교육/연구/개발 관점(투자 자문 아님). 실제 투자 적용 시 규정·리스크·수수료/세금·시장제도 등을 별도로 확인하세요.

---

## 0. 퀀트 알고리즘 한 장 요약(전체 흐름)

1) **데이터 수집**(가격/거래량/재무/공시/뉴스 등)  
2) **정합성/시간정렬**(point-in-time, 공시발표 시점 반영)  
3) **유니버스 선정**(상장폐지 포함, 유동성/가격 필터)  
4) **피처(특성) 생성**(모멘텀, 가치, 퀄리티, 변동성 등)  
5) **시그널 생성**(룰 기반 팩터 점수 / 통계 / ML 예측)  
6) **포트폴리오 구성**(종목 선택 + 비중 결정 + 제약조건)  
7) **백테스트**(거래비용·슬리피지·리밸런싱 반영)  
8) **검증/강건성 테스트**(워크포워드, 과최적화 진단)  
9) **실거래/모니터링**(주문·체결·리스크·드리프트 감시)  
10) **운영 자동화**(재학습/리밸런싱/리포트/버전관리)

---

## 1. 데이터: 퀀트가 실패하는 가장 흔한 이유

### 1.1 데이터 종류
- **가격/거래량(OHLCV)**: 일/분/틱  
- **기업행동(Corporate Actions)**: 액면분할, 배당, 유상증자 등  
- **재무/펀더멘털**: 분기/연간(발표 시점 중요)  
- **시장/섹터 분류**: GICS 등(리밸런싱/중립화에 활용)  
- **대체데이터(선택)**: 뉴스/공시 텍스트, 검색량, 위성 등

### 1.2 Point-in-time(시점 정합성)
백테스트가 “너무 좋게” 나오는 대표 원인:
- **미래 데이터를 과거에 사용**(Look-ahead bias)
- 재무데이터는 “해당 분기 종료일”이 아니라 **공시 발표일 이후**에만 사용해야 함  
- 데이터 공급사가 **backfill**(정정/추가)하는 경우, 과거 시점에서 알 수 없었던 값이 포함될 수 있음

**실무 체크**
- 각 데이터 row에 `effective_from`(사용 가능 시점), `as_of`(기준 시점) 메타를 둔다
- 재무/공시 데이터는 반드시 **발표일/수정일**을 추적한다

### 1.3 Survivorship bias(생존자 편향)
- 현재 살아남은 종목만으로 과거를 테스트하면 성과가 과대평가됨  
- **상장폐지/관리종목/거래정지** 이력 포함 필요

**실무 체크**
- 유니버스를 “그 당시 상장되어 있던 종목 전체”로 구성
- 가능한 경우 “상장/상폐 마스터 테이블”을 별도로 유지

### 1.4 데이터 품질 QA 체크리스트
- 결측치/이상치: 0 가격, 음수 거래량, 급격한 점프
- Corporate action 반영: 수정주가/원주가 혼용 금지
- 시간대/캘린더: 휴장일 처리, 리밸런싱 날짜 규칙 고정
- 종목코드 변경: 코드 체계 변경 시 mapping 필요

---

## 2. 유니버스(Universe) 설계

### 2.1 왜 유니버스가 중요?
전략의 절반은 “무엇을 투자 대상으로 삼느냐”에서 결정됩니다.
- 소형주·저유동성주를 포함하면 백테스트 수익이 좋아 보이지만 현실 체결이 어려울 수 있음
- 거래정지/급등락 종목이 많으면 슬리피지가 폭발

### 2.2 일반적인 유니버스 필터 예시(일봉 기준)
- 가격: `price > 1,000원` 같은 최소단위(시장별 상이)
- 유동성: `최근 20일 평균 거래대금 > X`
- 상장기간: `상장 후 6개월 이상`
- 관리/거래정지 제외(정책 결정 필요)
- 섹터 제한(선택)

> 팁: 시스템에서는 `universe_rule_version`을 별도로 두고, 전략과 독립적으로 관리하면 좋습니다.

---

## 3. 시그널 생성의 큰 분류(퀀트 알고리즘 지도)

퀀트 알고리즘은 크게 아래로 묶입니다.

1) **팩터/랭킹(크로스섹션)**: “오늘 기준 좋은 종목 Top N”  
2) **시계열(Time-series)**: “이 종목이 지금 추세/회귀 상태인가?”  
3) **통계적 차익/페어**: “두 자산 관계가 벌어졌으니 수렴을 노린다”  
4) **이벤트 기반**: “공시/실적/뉴스 이벤트 이후 평균 패턴”  
5) **마켓메이킹/초단타**: 개인/일반 프로젝트에서는 보통 제외(체결/인프라 난이도 큼)

이 문서는 1)~4)에 집중합니다.

---

## 4. 팩터(요인) 기반 종목추천 알고리즘

### 4.1 팩터 투자란?
“특정 특성(팩터)이 장기적으로 보상받는 경향”을 이용해  
종목을 점수화하고 상위/하위를 매수·매도(또는 롱/숏)합니다.

대표 팩터
- **Value**: 저평가(PBR↓, PER↓ 등)
- **Quality**: 수익성/재무건전(ROE↑, 부채↓, 이익의 질 등)
- **Momentum**: 과거 강한 수익률이 이어지는 경향
- **Low Volatility**: 변동성이 낮은 자산의 효율
- **Size**: 소형주 프리미엄(시장/국가별 상이)

### 4.2 가장 흔한 구현: “점수 → 랭킹 → 상위 N”
1) 각 종목에 대해 팩터 값을 계산  
2) 팩터별로 **표준화(z-score) 또는 퍼센타일 랭크**  
3) 여러 팩터를 가중합해 총점 `score` 생성  
4) 상위 N개 매수(또는 상위/하위 롱-숏)  
5) 월 1회/주 1회 리밸런싱

#### 표준화 방식 예시
- 퍼센타일: `rank_pct = rank(x) / (N-1)`
- z-score: `z = (x - mean(x)) / std(x)` (이상치에 취약)

#### 점수 결합 예시
- 단순 가중합: `score = 0.4*value + 0.3*quality + 0.3*momentum`
- 안전장치: `winsorize`(극단치 컷), `sector-neutral`(섹터 중립화)

### 4.3 리밸런싱 규칙
- **월말/월초 고정**: 운영/리포팅에 유리
- **주기**는 전략 성격과 거래비용에 좌우됨  
  - 모멘텀: 월/주  
  - 가치/퀄리티: 분기/월  
- 리밸런싱 때 “모든 종목 전량 교체”는 회전율 폭증 → **턴오버 제한**이 중요

### 4.4 턴오버(회전율) 제어
- 버퍼링: 기존 보유 종목은 **순위가 일정 수준 아래로 내려가야** 매도
- 최소 보유기간: N일/1개월 등
- 거래금지 구간: 이벤트/변동성 급증 시 리밸런싱 스킵(정책)

---

## 5. 시계열(Time-series) 기반 알고리즘

### 5.1 추세추종(Trend Following)
핵심 아이디어: 상승 추세면 보유/매수, 하락이면 축소/매도.

대표 시그널
- 이동평균 교차: `MA_short > MA_long`
- N일 수익률: `ret_12m` 등
- 돌파: `price > max(price, lookback)`

주의점
- 횡보장에서 휩쏘(가짜 신호) 많음
- 거래비용을 반드시 반영해야 함

### 5.2 평균회귀(Mean Reversion)
핵심 아이디어: 단기 급락/급등은 평균으로 되돌아온다.

대표 시그널
- 볼린저 밴드: `price < MA - k*std`
- z-score: `z < -2` 같은 과매도/과매수
- RSI(보조)

주의점
- 추세장에서는 “떨어지는 칼”이 될 수 있음 → 레짐 필터(추세/변동성) 필요

---

## 6. 페어/통계적 차익(StatArb) 기초

### 6.1 페어 트레이딩 기본
- 같은 업종/유사 비즈니스 두 종목 A,B를 선택
- 스프레드(가격 비율/차이)가 비정상적으로 벌어지면 수렴을 기대해 포지션 설정

대표 접근
- 상관/공적분(cointegration) 기반
- 스프레드 z-score 기반 진입/청산

현실 난점
- 차입/공매도 제약(시장별)
- 구조적 변화(기업 펀더멘털 변화)로 관계 붕괴

---

## 7. 포트폴리오 구성(비중 결정) 알고리즘

### 7.1 단순하지만 강력한 방식
- **Equal Weight**: 선택된 종목에 동일 비중
- **Score Proportional**: 점수에 비례해 비중 배분(상한/하한 필요)
- **Volatility Targeting**: 변동성이 큰 종목 비중 축소

### 7.2 리스크 예산: Risk Parity(개념)
- “자산/팩터별 위험 기여도를 비슷하게 맞추자”  
- 기대수익 추정이 어려울 때 포트폴리오를 안정적으로 만드는 접근

(리스크 패리티는 다자산에 더 흔하지만, **종목/섹터 단위**로 응용 가능)

### 7.3 제약조건(실무에서 꼭 필요)
- 종목 최대비중: `w_i <= 5%`
- 섹터 최대비중: `sector_w <= 25%`
- 최소 거래단위/호가단위 반영
- 유동성 한도: “일평균 거래대금의 x% 이상 매수 금지”
- 턴오버 제한: `sum(|w_t - w_{t-1}|) <= T`

---

## 8. 백테스트 설계(실패를 막는 핵심 파트)

### 8.1 백테스트 “필수” 구성요소
- 리밸런싱 캘린더(예: 매월 첫 거래일)
- 체결 가정(종가/시가/다음날 VWAP 등)
- 거래비용(수수료+세금+슬리피지)
- 결측/거래정지 처리 정책
- 기업행동 반영(수정주가/배당 재투자 여부)

### 8.2 대표적인 함정 체크(반드시 방지)
- Look-ahead bias(미래 정보 사용)
- Survivorship bias(생존자 편향)
- Data-snooping(너무 많은 실험 후 우연히 맞은 모델 선택)
- Overfitting(과최적화) / 미세 파라미터 튜닝 중독
- 거래비용/슬리피지 무시

### 8.3 과최적화 진단(고급)
- 워크포워드(rolling) 평가
- 파라미터 민감도 분석(조금 바꿔도 성과가 유지되는가?)
- Combinatorially Symmetric Cross-Validation(CSCV) 같은 방법으로
  “좋아 보이는 백테스트가 우연일 확률”을 추정(PBO, PSR 등)

---

## 9. ML(머신러닝) 기반 종목추천 알고리즘

### 9.1 문제정의 3가지 패턴
1) **회귀**: 미래 수익률 예측(노이즈 큼)  
2) **분류**: “상위 수익률 그룹인가?”(Top/Bottom)  
3) **랭킹/스코어링**: 종목을 순서대로 정렬하는 점수 예측(실무 적합)

> 실무 팁: “정확한 수익률 수치”보다 **랭킹 문제**가 더 안정적인 편입니다.

### 9.2 피처 엔지니어링(예시)
- 가격 기반: 1/5/20/60/252일 수익률, 변동성, 최대낙폭, 거래대금 변화
- 팩터 기반: value/quality/momentum 점수
- 위험: 베타, 섹터 더미, 시장국면 지표(변동성)

### 9.3 학습/평가 프로토콜(중요)
- 시간 순서 유지: 랜덤 셔플 금지(시계열 누수)
- 학습/검증/테스트를 시간으로 분리
- 지표:
  - 예측 정확도보다 **포트폴리오 성과 지표**가 더 중요(샤프, MDD, 턴오버)
- 안정화:
  - 규제/정규화, 단순 모델부터(Linear/Tree) → 복잡 모델은 마지막

### 9.4 “모델 성능”과 “전략 성능”은 다르다
- 모델의 AUC가 좋아도, 거래비용 고려하면 수익이 안 날 수 있음
- 모델 출력 → 포트폴리오 구성 단계가 성과를 크게 좌우

---

## 10. 운영(Production) 관점 체크리스트

### 10.1 파이프라인 구성
- 배치 스케줄:
  - 장 마감 후 데이터 적재
  - 신호 계산
  - 리밸런싱 주문 리스트 생성
  - 리포트/알림 생성
- 버전관리:
  - 전략 정의 JSON(룰/가중치/유니버스/비용 가정) 버전
  - 데이터 스냅샷 버전(재현 가능성)

### 10.2 모니터링
- 데이터 누락/지연 알림
- 백테스트 대비 드리프트:
  - 수익률/변동성/턴오버/섹터 편중
- 체결 리포트:
  - 예상 대비 슬리피지, 미체결률

### 10.3 “설명 가능한 추천”
종목추천 시스템이라면 “왜 추천했는지”가 중요합니다.
- 팩터 기여도(각 팩터 점수)
- 최근 변화(모멘텀 개선, 밸류 저평가 확대 등)
- 리스크(변동성, 섹터 편중)와 제약조건 만족 여부

---

## 11. 구현 템플릿(의사코드)

### 11.1 팩터 랭킹 기반 월간 리밸런싱
```pseudo
for each rebalance_date t:
  universe = get_universe(t)

  features = compute_features(universe, as_of=t)        # point-in-time
  scores   = rank_and_combine(features)                 # percentile or zscore
  picks    = topN(scores, N)

  target_weights = equal_weight(picks)
  target_weights = apply_constraints(target_weights)    # max weight, sector cap
  orders = diff_to_orders(current_positions, target_weights)

  simulated_fills = execute(orders, price_model="next_open", tc_model=...)
  update_portfolio(simulated_fills)
```

### 11.2 거래비용 모델(단순형)
- 수수료: `commission = notional * fee_rate`
- 세금(해당 시장 적용): `tax = sell_notional * tax_rate`
- 슬리피지(예): `slippage = notional * slip_bps / 10000`

> 단순형이라도 “0”보다 훨씬 낫습니다. 전략 비교에는 충분히 유용합니다.

---

## 12. 추천: “주식종목추천 MVP”에서 가장 현실적인 2가지

### MVP-1: 팩터 3종(가치+퀄리티+모멘텀) 랭킹
- 장점: 구현/설명 쉬움, 과최적화 위험 상대적으로 낮음  
- 구성:
  - Universe: 유동성 필터
  - Features: PBR/ROE/12m momentum 등
  - Rebalance: 월 1회
  - Portfolio: equal-weight + sector cap + turnover limit

### MVP-2: 랭킹 ML(트리 기반) + 단순 제약 포트폴리오
- 장점: 피처 추가에 유연, RAG/뉴스점수도 합칠 수 있음  
- 구성:
  - Label: 다음 1개월 수익률 상위 20% 여부(분류) 또는 수익률(랭킹)
  - Model: LightGBM/XGBoost(가능하면 단순부터)
  - Output: 종목 점수 → Top N → 제약 포트폴리오

---

## 13. 참고 문헌/키워드(검색용)
- “Fama-French factors (Mkt-RF, SMB, HML, RMW, CMA)”
- “Momentum factor UMD”
- “Backtest overfitting, PBO, CSCV”
- “Point-in-time data, survivorship bias”
- “Risk parity portfolio construction”
- “Factor investing value quality momentum”

---

## 14. 다음 단계(원하시면)
원하시면 아래 중 하나를 골라서, **당장 코드로 옮길 수 있게** 더 구체화해드릴게요.
1) “팩터 3종 랭킹 전략”을 **DB 스키마 + 배치잡 + 백테스트 구조**로 설계  
2) “ML 랭킹 모델”을 **학습/검증 분리 + 피처 스토어 + 리포트**까지 설계  
3) “RAG로 공시/뉴스 근거”를 붙여 **설명 가능한 추천 리포트** 템플릿 제작
